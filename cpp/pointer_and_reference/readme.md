# 포인터와 레퍼런스에 대해서

우리는 특정 메모리 공간을 액세스 하기 위해서 변수를 사용한다. 다음과 같이 변수를 선언하고 값을 할당한 후 해당 값을 사용하기 위해 변수를 사용한다.

```c++
string name = "greenfrog";
cout << "My name is " << name << "." << endl;

// My name is greenfrog.
```

이때, 포인터는 이 변수에 할당 된 값의 메모리 공간의 주소를 직접 가리키고, 포인터 연산을 통해 주소값을 직접 변경할 수 있다. **다시 말해서, 포인터의 경우 포인터가 가리키는 메모리 공간에 직접 접근이 가능하다.**

```c++
int val = 100;
int* pVal = &val;

val = 200;

cout << "val : " << val << endl;
cout << "*pVal : " << *pVal << endl;

// val : 200
// *pVal : 200

pVal++; // 포인터 연산을 통해 4byte만큼 주소 공간을 이동한다.
cout << "*pVal : " << *pVal << endl; // 메모리 참조 오류 발생!!
```

반면, 레퍼런스는 변수에 별명을 붙여주는 것이다. 다시 말해서, 레퍼런스는 이름이 존재하는 메모리 공간에 하나의 이름을 더 부여하는 행위로서 레퍼런스와 변수는 생성되는 방법에 있어서만 차이를 보일 뿐 일단 만들어지고 나면 완전히 같은 것이다.

```c++
int val = 100;
int& _val = val;

val = 200;

cout << "val : " << val << endl;
cout << "_val : " << _val << endl;

// val : 200
// _val : 200

_val++;

cout << "val : " << val << endl;
cout << "_val : " << _val << endl;

// val : 201
// _val : 201
```

어떻게 보면 포인터도 특정 변수의 메모리 주소를 가리키는 방식으로 해당변수의 값을 참조하고, 레퍼런스도 특정 변수의 메모리 공간에 레퍼런스 변수 이름을 부여하여 해당변수의 값을 참조하는데 가장 두드러진 차이점은 무엇일까?

이는 **메모리 주소 공간에 대한 직접 조작 가능 여부**가 될 것이다. 포인터의 경우 메모리 주소 공간에 대한 직접 조작이 가능하기 때문에 주소 공간 침범등의 문제를 가져올 수 있지만, 레퍼런스의 경우 메모리 주소 공간에 대한 직접 조작이 불가능하기 때문에 좀 더 안전하게 변수를 참조할 수 있다.

C#이나 Java등의 다른 언어들 역시 포인터 연산의 이러한 위험성 때문에 포인터를 없애고 레퍼런스 기반 디자인 되었다.

## 참조

* C++ 프로그래밍, 윤성우 저, FREELEC
* [C++ 포인터와 레퍼런스의 차이](http://wonjayk.tistory.com/253)
* [TIP. 포인터(pointer)와 참조자(reference)의 차이점에 대해서 알고가자.](http://whitesnake.uzoo.in/29)
