# 3주차 스터디 

* UNIT 21 배열 사용하기 

## UNIT 21. 배열 사용하기 

### 배열 정의하기 

배열은 다음과 같은 형식으로 정의한다. 

> var 배열명 [길이]자료형

* 다른 언어들은 배열의 원소를 정의할 때 []로 정의 하지만 Go에서는 {}로 정의한다. 
* 배열의 원소 정의 없이 선언만 할 경우 모든 값이 0으로 초기화 된다.  
* 배열 선언 시 원소를 정의하지 않았다며냐 반드시 원소의 개수를 정의해주어야 하는데, 원소를 정의했다면 **...**으로 대신할 수 있다.   
  **...** 보다는 그냥 비워놓는 것이 더 편했을 것 같다. **...**을 사용하지 않으면 에러가 발생하므로 주의하자. 
* 배열 선언 시 원소를 정의할 때 한줄로 정의하지 안혹 여러줄을 사용할 수 있다. 이때는 반드시 마지막 원소에 **,**를 붙여주어야한다.


```go
var a1 [5]int = [5]int{1,2,3,4,5}
var a2 = [5]int{1,2,3,4,5}
a3 := [5]int{1,2,3,4,5}
a4 := [...]int{1,2,3,4,5}
a5 := [...]int {
    1,
    2,
    3,
    4,
    5,
}

fmt.Println(a1)
fmt.Println(a2)
fmt.Println(a3)
fmt.Println(a4)
```

### 다차원 배열 정의하기

다차원 배열은 다음과 같은 형식으로 정의한다. 일반 배을 정의하는 것과 크게 다르지 않다. 

> var 배열명 [길이][길이]자료형

```go
var multi1 [2][2]int
fmt.Println(multi1)

multi2 := [3][2]int {
    {1, 2},
    {3, 4},
    {4, 5},
}
fmt.Println(multi2)
```

#### 다차원 배열에서 ... 사용하기 

앞서 다차원 배열을 정의할 때는 원소의 개수를 함께 선언하였다.  
이번에는 **...**을 사용해서 다차원 배열의 정의해보자.

우선 다음과 같이 행, 열 모두를 **...**로 정의해보자. 

```go
multi3 := [...][...]int {
    {1, 2},
    {3, 4}
}
fmt.Println(multi3)
```

위 코드는 다음과 같이 에러가 발생한다. 

```sh
./ex_21.go:40:17: use of [...] array outside of array literal
```

이는 **열**을 정의하는 자리에 **...**을 사용해서 발생한 에러이다.  
다시 말해서, Go의 배열은 각 행마다 원소의 개수가 다른 것을 허용하지 않는다. 따라서, 각 행의 원소의 개수를 정의를 해주어야한다.
앞선 예제를 옳바르게 수정하면 다음과 같다. 

```go
multi3 := [...][2]int {
    {1, 2},
    {3, 4},
}
fmt.Println(multi3)
```

## 21.1 배열 순회하기 

### len 사용하기

가장 일반적인 방법으로 C/C++을 사용할 때 쓰던 방법이다. 
다음과 같다. 

```go
a := [...]int{1, 2, 3, 4, 5}
for i:=0; i<len(a); i++ {
    fmt.Println(a[i])
}
```

### range 사용하기

**range**는 전달 받은 배열의 index와 원소를 함께 반환해준다. 

```go
a := [...]int{1, 2, 3, 4, 5}
for i, value := range a {
    fmt.Println(i, value)
}
```

그러면 **ranage**를 통해 다차원 배열을 순회해보자.  
다음과 같다. 

```go
b := [...][2]int {
    {1, 2},
    {3, 4},
}

for i, row := range b {
    for j, value := range row {
        fmt.Println(i, j, value)
    }
}
```

### 주의점 

**range**를 사용할 때 주의할 점은 **range**을 반환 값을 두개를 모두 정의하지 않고 하나만 정의하면 배열의 index만 반환된다는 것이다. 
예를들어 앞선 예제애서 value 변수를 선언하지 않았다면 index만 반환된다. 
다음 예제를 보자. 

```go
for idx := range a {
    fmt.Println(idx)
}
```

그러면 인덱스는 생략하고 값만 사용하는 방법은 없을까? 
**range**의 인덱스가 반환되는 위치에 **_(underscore)**를 쓰고 값을 받는 변수를 선언하면 된다.  
다음 예제를 보자.

```go
for _, value := range a {
    fmt.Println(value)
}
```

위 예제에서 **_(underscore)** 사용을 보고 그냥 변수명을 쓰고 사용하지 않는 방법도 있을 텐데 굳이 **_(unserscore)**을 사용하는 이유가 궁금하다.  
위 예제를 다음과 같이 수정하고 실행해보자. 

```go
for i, value := range a {
    fmt.Println(value)
}
```

다음과 같이 바로 에러가 난다. 
앞서 1주차에서도 공부했지만 Go는 사용하지 않는 변수와 import 패키지등에 대해서 에러를 발생시킨다. 따라서 반드시 **_(underscore)**를 사용해주어야한다.

```sh
./ex_21.1.go:51:9: i declared and not used
```

## 21.2 배열복사 하기 

일반적으로 그 동안 내가 다루었던 C/C++, Java, C#, JavaScript, Python에서는 배열을 변수에 할당하면 값을 할당하지 않고 주소를 할당한다.  
하지만, Go에서는 값을 할당한다. 따라서 배열을 복사하기 위해서는 다른 변수에 할당해주기만 하면된다. 
다음과 같다. 

```go
a := [...]int{1, 2, 3}
b := a

fmt.Println(a)
b[1] = 100
fmt.Println(b)
```
