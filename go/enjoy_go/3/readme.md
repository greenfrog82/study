# 3주차 스터디 

* UNIT 21. 배열 사용하기 
* UNIT 22. 슬라이스 사용하기 
* UNIT 23. 맵 사용하기 

## UNIT 21. 배열 사용하기 

### 배열 정의하기 

배열은 다음과 같은 형식으로 정의한다. 

> var 배열명 [길이]자료형

* 다른 언어들은 배열의 원소를 정의할 때 []로 정의 하지만 Go에서는 {}로 정의한다. 
* 배열의 원소 정의 없이 선언만 할 경우 모든 값이 0으로 초기화 된다.  
* 배열 선언 시 원소를 정의하지 않았다며냐 반드시 원소의 개수를 정의해주어야 하는데, 원소를 정의했다면 **...**으로 대신할 수 있다.   
  **...** 보다는 그냥 비워놓는 것이 더 편했을 것 같다. **...**을 사용하지 않으면 에러가 발생하므로 주의하자. 
* 배열 선언 시 원소를 정의할 때 한줄로 정의하지 안혹 여러줄을 사용할 수 있다. 이때는 반드시 마지막 원소에 **,**를 붙여주어야한다.


```go
var a1 [5]int = [5]int{1,2,3,4,5}
var a2 = [5]int{1,2,3,4,5}
a3 := [5]int{1,2,3,4,5}
a4 := [...]int{1,2,3,4,5}
a5 := [...]int {
    1,
    2,
    3,
    4,
    5,
}

fmt.Println(a1)
fmt.Println(a2)
fmt.Println(a3)
fmt.Println(a4)
```

### 다차원 배열 정의하기

다차원 배열은 다음과 같은 형식으로 정의한다. 일반 배을 정의하는 것과 크게 다르지 않다. 

> var 배열명 [길이][길이]자료형

```go
var multi1 [2][2]int
fmt.Println(multi1)

multi2 := [3][2]int {
    {1, 2},
    {3, 4},
    {4, 5},
}
fmt.Println(multi2)
```

#### 다차원 배열에서 ... 사용하기 

앞서 다차원 배열을 정의할 때는 원소의 개수를 함께 선언하였다.  
이번에는 **...**을 사용해서 다차원 배열의 정의해보자.

우선 다음과 같이 행, 열 모두를 **...**로 정의해보자. 

```go
multi3 := [...][...]int {
    {1, 2},
    {3, 4}
}
fmt.Println(multi3)
```

위 코드는 다음과 같이 에러가 발생한다. 

```sh
./ex_21.go:40:17: use of [...] array outside of array literal
```

이는 **열**을 정의하는 자리에 **...**을 사용해서 발생한 에러이다.  
다시 말해서, Go의 배열은 각 행마다 원소의 개수가 다른 것을 허용하지 않는다. 따라서, 각 행의 원소의 개수를 정의를 해주어야한다.
앞선 예제를 옳바르게 수정하면 다음과 같다. 

```go
multi3 := [...][2]int {
    {1, 2},
    {3, 4},
}
fmt.Println(multi3)
```

## 21.1 배열 순회하기 

### len 사용하기

가장 일반적인 방법으로 C/C++을 사용할 때 쓰던 방법이다. 
다음과 같다. 

```go
a := [...]int{1, 2, 3, 4, 5}
for i:=0; i<len(a); i++ {
    fmt.Println(a[i])
}
```

### range 사용하기

**range**는 전달 받은 배열의 index와 원소를 함께 반환해준다. 

```go
a := [...]int{1, 2, 3, 4, 5}
for i, value := range a {
    fmt.Println(i, value)
}
```

그러면 **ranage**를 통해 다차원 배열을 순회해보자.  
다음과 같다. 

```go
b := [...][2]int {
    {1, 2},
    {3, 4},
}

for i, row := range b {
    for j, value := range row {
        fmt.Println(i, j, value)
    }
}
```

### 주의점 

**range**를 사용할 때 주의할 점은 **range**을 반환 값을 두개를 모두 정의하지 않고 하나만 정의하면 배열의 index만 반환된다는 것이다. 
예를들어 앞선 예제애서 value 변수를 선언하지 않았다면 index만 반환된다. 
다음 예제를 보자. 

```go
for idx := range a {
    fmt.Println(idx)
}
```

그러면 인덱스는 생략하고 값만 사용하는 방법은 없을까? 
**range**의 인덱스가 반환되는 위치에 **_(underscore)**를 쓰고 값을 받는 변수를 선언하면 된다.  
다음 예제를 보자.

```go
for _, value := range a {
    fmt.Println(value)
}
```

위 예제에서 **_(underscore)** 사용을 보고 그냥 변수명을 쓰고 사용하지 않는 방법도 있을 텐데 굳이 **_(unserscore)**을 사용하는 이유가 궁금하다.  
위 예제를 다음과 같이 수정하고 실행해보자. 

```go
for i, value := range a {
    fmt.Println(value)
}
```

다음과 같이 바로 에러가 난다. 
앞서 1주차에서도 공부했지만 Go는 사용하지 않는 변수와 import 패키지등에 대해서 에러를 발생시킨다. 따라서 반드시 **_(underscore)**를 사용해주어야한다.

```sh
./ex_21.1.go:51:9: i declared and not used
```

## 21.2 배열복사 하기 

일반적으로 그 동안 내가 다루었던 C/C++, Java, C#, JavaScript, Python에서는 배열을 변수에 할당하면 값을 할당하지 않고 주소를 할당한다.  
하지만, Go에서는 값을 할당한다. 따라서 배열을 복사하기 위해서는 다른 변수에 할당해주기만 하면된다. 
다음과 같다. 

```go
a := [...]int{1, 2, 3}
b := a

fmt.Println(a)
b[1] = 100
fmt.Println(b)
```

## UNIT 22. 슬라이스 사용하기 

슬라이스는 배열과 달리 참조형이다. 
C++을 해봤다면 vector를 생각하면 아주 비슷하다.

### 슬라이스 선언하기

슬라이스는 다음과 같은 형태로 정의한다. 

>var 슬라이스명 []자료형 

예를들어, 다음과 같이 선언해보자. 

```go
var a []int
```

### 슬라이스 정의하기 

슬라이스를 정의하는 방법은 다음 두가지가 있다. 

* make 함수 사용하기 
* 선언과 동시에 슬라이스 할당하기 

#### make 함수 사용하기 

위와 같이 선언만 하면 길이가 0인 슬라이스가 생성된다. 이를 사용하기 위해서는 **make** 함수를 통해서 공간을 할당해주어야한다.   
**make**함수는 다음과 같은 형식으로 사용한다. 

>make([]자료형, len, caps)

* []자료형 : 슬라이스의 자료형
* len : 슬라이스의 길이
* caps : 슬라이스의 용량 

앞서 언급했드시 C++의 vector와 아주 비슷하다.
할당되는 원소 수에 가변되는 길이를 미리 예상하여 **caps** 파라메터로 전달하면 미리 메모리에 공간을 할당해둔다.  
따라서 가변을 목적으로하는 슬라이스의 성능을 향상시킬 수 있을 것이다. 

[?] 
슬라이스가 미리 메모리 공간을 확보하여 성능 향상을 꽤하는 것으로 보아 슬라이스는 LinkedList 형태로 구현되어 있는 것이 아닌 배열 형태로 개발 되어 있을 것 같다.  
따라서 슬라이스의 길이가 초과할때 마다 해당 길이만큼 공간을 확보하고 기존 배열을 복사하는 등의 문제를 capacity를 통해 해결했을 것이다.  
이 부분은 확인이 필요하다. 

다음은 make 함수의 len 파라메터만을 전달하여 슬라이스를 정의하는 예제이다. 

```go
var a []int = make([]int, 5)
var b = make([]int, 5)
c := make([]int, 5)
```

이러한 방법을 사용하면 길이가 5이고 용량이 5인 슬라이스가 생성된다. 
이렇게 되면 용량이 늘어날때 마다 슬라이스는 매번 용량을 할당하고 기존 슬라이스의 원소를 복사하는 동작을 반복할 것이다.  
[?] 따라서, 이런식의 사용의 극히 제한적일 것으로 생각된다.  
예를들어, 배열 형태이지만 참조형으로 사용하고 싶을때? 사실 이 경우도 배열 부분적으로 슬라이스화 시키면 해결할 수 있는 부분이긴하지만 ... 아직 잘 모르곘다.  
우선 나의 경우 이런식으로 길이만을 정의해서 사용하지는 않을 듯. 

그러면 caps를 전달해서 슬라이스를 생성하여 보자. 

```go
var a []int = make([]int, 5, 10)

fmt.Println(len(a)) // 5 출력
fmt.Println(cap(a)) // 10 출력 
```

**len** 함수는 슬라이스의 길이를 구하는 함수이고, **cap** 함수는 슬라이스의 용량을 구하는 함수이다.

#### 선언과 동시에 사용하기

슬라이스는 다음과 같이 선언과 동시에 정의가 가능하다. 

```go
b := []int{1, 2, 3, 4}

fmt.Println(len(b))
fmt.Println(cap(b))
```

[?] 
하지만 이 방법 역시 용량을 정해주지 못하므로 과연 많이 사용될지 모르겠다.  
용량도 설정하면서 선언과 동시에 슬라이스의 원소를 정의하는 방법은 없는가?


### 22.1 슬라이스에 값 추가하기 

**append** 함수를 사용하면 슬라이스의 맨 뒤에 값 또는 같은 타입의 다른 슬라이스의 값을 추가 할 수 있다.  

#### 값 추가하기



#### 같은 타입의 다른 슬라이스의 값 추가하기 


## UNIT 23. 맵 사용하기 

* map 사용 예제에서 if 예제가 이제 익숙해졌음. 
* 